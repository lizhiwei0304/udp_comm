# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from lanelet_map_msgs/LaneletMap.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import lanelet_map_msgs.msg
import geometry_msgs.msg
import std_msgs.msg

class LaneletMap(genpy.Message):
  _md5sum = "3579fead11f7e76167ff825b6fd746c4"
  _type = "lanelet_map_msgs/LaneletMap"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header
Lanelet[] current_lane
Lanelet left_beside
Lanelet right_beside
Lanelet[] forward_following
Lanelet[] forward_right
Lanelet[] forward_left


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: lanelet_map_msgs/Lanelet
int32 id
Way left_bound
Way right_bound
Way centerline
Regulatory regulatory_elements

================================================================================
MSG: lanelet_map_msgs/Way
string task_area
int8 is_forward
int8 open_concave_obs_det
int8 open_dynamic_obs_det
int8 open_foggy_det
int8 open_water_det
int8 foggy_area
int8 lawn_area
int8 water_area
float64 vel_limit
Node[] points

================================================================================
MSG: lanelet_map_msgs/Node
int32 id
string type
float64 vlimit
geometry_msgs/Point point

================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z

================================================================================
MSG: lanelet_map_msgs/Regulatory
Node[] special_nodes
Way[] special_ways
"""
  __slots__ = ['header','current_lane','left_beside','right_beside','forward_following','forward_right','forward_left']
  _slot_types = ['std_msgs/Header','lanelet_map_msgs/Lanelet[]','lanelet_map_msgs/Lanelet','lanelet_map_msgs/Lanelet','lanelet_map_msgs/Lanelet[]','lanelet_map_msgs/Lanelet[]','lanelet_map_msgs/Lanelet[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,current_lane,left_beside,right_beside,forward_following,forward_right,forward_left

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(LaneletMap, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.current_lane is None:
        self.current_lane = []
      if self.left_beside is None:
        self.left_beside = lanelet_map_msgs.msg.Lanelet()
      if self.right_beside is None:
        self.right_beside = lanelet_map_msgs.msg.Lanelet()
      if self.forward_following is None:
        self.forward_following = []
      if self.forward_right is None:
        self.forward_right = []
      if self.forward_left is None:
        self.forward_left = []
    else:
      self.header = std_msgs.msg.Header()
      self.current_lane = []
      self.left_beside = lanelet_map_msgs.msg.Lanelet()
      self.right_beside = lanelet_map_msgs.msg.Lanelet()
      self.forward_following = []
      self.forward_right = []
      self.forward_left = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.current_lane)
      buff.write(_struct_I.pack(length))
      for val1 in self.current_lane:
        buff.write(_get_struct_i().pack(val1.id))
        _v1 = val1.left_bound
        _x = _v1.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v1
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v1.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v1.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v2 = val3.point
          _x = _v2
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v3 = val1.right_bound
        _x = _v3.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v3
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v3.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v3.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v4 = val3.point
          _x = _v4
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v5 = val1.centerline
        _x = _v5.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v5
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v5.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v5.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v6 = val3.point
          _x = _v6
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v7 = val1.regulatory_elements
        length = len(_v7.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v7.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v8 = val3.point
          _x = _v8
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v7.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v7.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v9 = val4.point
            _x = _v9
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      buff.write(_get_struct_i().pack(self.left_beside.id))
      _x = self.left_beside.left_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.left_beside.left_bound.is_forward, _x.left_beside.left_bound.open_concave_obs_det, _x.left_beside.left_bound.open_dynamic_obs_det, _x.left_beside.left_bound.open_foggy_det, _x.left_beside.left_bound.open_water_det, _x.left_beside.left_bound.foggy_area, _x.left_beside.left_bound.lawn_area, _x.left_beside.left_bound.water_area, _x.left_beside.left_bound.vel_limit))
      length = len(self.left_beside.left_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.left_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v10 = val1.point
        _x = _v10
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.left_beside.right_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.left_beside.right_bound.is_forward, _x.left_beside.right_bound.open_concave_obs_det, _x.left_beside.right_bound.open_dynamic_obs_det, _x.left_beside.right_bound.open_foggy_det, _x.left_beside.right_bound.open_water_det, _x.left_beside.right_bound.foggy_area, _x.left_beside.right_bound.lawn_area, _x.left_beside.right_bound.water_area, _x.left_beside.right_bound.vel_limit))
      length = len(self.left_beside.right_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.right_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v11 = val1.point
        _x = _v11
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.left_beside.centerline.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.left_beside.centerline.is_forward, _x.left_beside.centerline.open_concave_obs_det, _x.left_beside.centerline.open_dynamic_obs_det, _x.left_beside.centerline.open_foggy_det, _x.left_beside.centerline.open_water_det, _x.left_beside.centerline.foggy_area, _x.left_beside.centerline.lawn_area, _x.left_beside.centerline.water_area, _x.left_beside.centerline.vel_limit))
      length = len(self.left_beside.centerline.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.centerline.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v12 = val1.point
        _x = _v12
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.left_beside.regulatory_elements.special_nodes)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.regulatory_elements.special_nodes:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v13 = val1.point
        _x = _v13
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.left_beside.regulatory_elements.special_ways)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.regulatory_elements.special_ways:
        _x = val1.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(val1.points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.points:
          buff.write(_get_struct_i().pack(val2.id))
          _x = val2.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val2.vlimit))
          _v14 = val2.point
          _x = _v14
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      buff.write(_get_struct_i().pack(self.right_beside.id))
      _x = self.right_beside.left_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.right_beside.left_bound.is_forward, _x.right_beside.left_bound.open_concave_obs_det, _x.right_beside.left_bound.open_dynamic_obs_det, _x.right_beside.left_bound.open_foggy_det, _x.right_beside.left_bound.open_water_det, _x.right_beside.left_bound.foggy_area, _x.right_beside.left_bound.lawn_area, _x.right_beside.left_bound.water_area, _x.right_beside.left_bound.vel_limit))
      length = len(self.right_beside.left_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.left_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v15 = val1.point
        _x = _v15
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.right_beside.right_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.right_beside.right_bound.is_forward, _x.right_beside.right_bound.open_concave_obs_det, _x.right_beside.right_bound.open_dynamic_obs_det, _x.right_beside.right_bound.open_foggy_det, _x.right_beside.right_bound.open_water_det, _x.right_beside.right_bound.foggy_area, _x.right_beside.right_bound.lawn_area, _x.right_beside.right_bound.water_area, _x.right_beside.right_bound.vel_limit))
      length = len(self.right_beside.right_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.right_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v16 = val1.point
        _x = _v16
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.right_beside.centerline.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.right_beside.centerline.is_forward, _x.right_beside.centerline.open_concave_obs_det, _x.right_beside.centerline.open_dynamic_obs_det, _x.right_beside.centerline.open_foggy_det, _x.right_beside.centerline.open_water_det, _x.right_beside.centerline.foggy_area, _x.right_beside.centerline.lawn_area, _x.right_beside.centerline.water_area, _x.right_beside.centerline.vel_limit))
      length = len(self.right_beside.centerline.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.centerline.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v17 = val1.point
        _x = _v17
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.right_beside.regulatory_elements.special_nodes)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.regulatory_elements.special_nodes:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v18 = val1.point
        _x = _v18
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.right_beside.regulatory_elements.special_ways)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.regulatory_elements.special_ways:
        _x = val1.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(val1.points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.points:
          buff.write(_get_struct_i().pack(val2.id))
          _x = val2.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val2.vlimit))
          _v19 = val2.point
          _x = _v19
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.forward_following)
      buff.write(_struct_I.pack(length))
      for val1 in self.forward_following:
        buff.write(_get_struct_i().pack(val1.id))
        _v20 = val1.left_bound
        _x = _v20.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v20
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v20.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v20.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v21 = val3.point
          _x = _v21
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v22 = val1.right_bound
        _x = _v22.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v22
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v22.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v22.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v23 = val3.point
          _x = _v23
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v24 = val1.centerline
        _x = _v24.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v24
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v24.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v24.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v25 = val3.point
          _x = _v25
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v26 = val1.regulatory_elements
        length = len(_v26.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v26.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v27 = val3.point
          _x = _v27
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v26.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v26.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v28 = val4.point
            _x = _v28
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.forward_right)
      buff.write(_struct_I.pack(length))
      for val1 in self.forward_right:
        buff.write(_get_struct_i().pack(val1.id))
        _v29 = val1.left_bound
        _x = _v29.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v29
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v29.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v29.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v30 = val3.point
          _x = _v30
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v31 = val1.right_bound
        _x = _v31.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v31
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v31.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v31.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v32 = val3.point
          _x = _v32
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v33 = val1.centerline
        _x = _v33.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v33
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v33.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v33.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v34 = val3.point
          _x = _v34
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v35 = val1.regulatory_elements
        length = len(_v35.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v35.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v36 = val3.point
          _x = _v36
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v35.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v35.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v37 = val4.point
            _x = _v37
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.forward_left)
      buff.write(_struct_I.pack(length))
      for val1 in self.forward_left:
        buff.write(_get_struct_i().pack(val1.id))
        _v38 = val1.left_bound
        _x = _v38.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v38
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v38.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v38.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v39 = val3.point
          _x = _v39
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v40 = val1.right_bound
        _x = _v40.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v40
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v40.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v40.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v41 = val3.point
          _x = _v41
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v42 = val1.centerline
        _x = _v42.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v42
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v42.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v42.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v43 = val3.point
          _x = _v43
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v44 = val1.regulatory_elements
        length = len(_v44.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v44.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v45 = val3.point
          _x = _v45
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v44.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v44.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v46 = val4.point
            _x = _v46
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.current_lane is None:
        self.current_lane = None
      if self.left_beside is None:
        self.left_beside = lanelet_map_msgs.msg.Lanelet()
      if self.right_beside is None:
        self.right_beside = lanelet_map_msgs.msg.Lanelet()
      if self.forward_following is None:
        self.forward_following = None
      if self.forward_right is None:
        self.forward_right = None
      if self.forward_left is None:
        self.forward_left = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.current_lane = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v47 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v47.task_area = str[start:end].decode('utf-8')
        else:
          _v47.task_area = str[start:end]
        _x = _v47
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v47.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v48 = val3.point
          _x = _v48
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v47.points.append(val3)
        _v49 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v49.task_area = str[start:end].decode('utf-8')
        else:
          _v49.task_area = str[start:end]
        _x = _v49
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v49.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v50 = val3.point
          _x = _v50
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v49.points.append(val3)
        _v51 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v51.task_area = str[start:end].decode('utf-8')
        else:
          _v51.task_area = str[start:end]
        _x = _v51
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v51.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v52 = val3.point
          _x = _v52
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v51.points.append(val3)
        _v53 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v53.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v54 = val3.point
          _x = _v54
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v53.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v53.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v55 = val4.point
            _x = _v55
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v53.special_ways.append(val3)
        self.current_lane.append(val1)
      start = end
      end += 4
      (self.left_beside.id,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.left_beside.left_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.left_beside.left_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.left_beside.left_bound.is_forward, _x.left_beside.left_bound.open_concave_obs_det, _x.left_beside.left_bound.open_dynamic_obs_det, _x.left_beside.left_bound.open_foggy_det, _x.left_beside.left_bound.open_water_det, _x.left_beside.left_bound.foggy_area, _x.left_beside.left_bound.lawn_area, _x.left_beside.left_bound.water_area, _x.left_beside.left_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.left_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v56 = val1.point
        _x = _v56
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.left_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.left_beside.right_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.left_beside.right_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.left_beside.right_bound.is_forward, _x.left_beside.right_bound.open_concave_obs_det, _x.left_beside.right_bound.open_dynamic_obs_det, _x.left_beside.right_bound.open_foggy_det, _x.left_beside.right_bound.open_water_det, _x.left_beside.right_bound.foggy_area, _x.left_beside.right_bound.lawn_area, _x.left_beside.right_bound.water_area, _x.left_beside.right_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.right_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v57 = val1.point
        _x = _v57
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.right_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.left_beside.centerline.task_area = str[start:end].decode('utf-8')
      else:
        self.left_beside.centerline.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.left_beside.centerline.is_forward, _x.left_beside.centerline.open_concave_obs_det, _x.left_beside.centerline.open_dynamic_obs_det, _x.left_beside.centerline.open_foggy_det, _x.left_beside.centerline.open_water_det, _x.left_beside.centerline.foggy_area, _x.left_beside.centerline.lawn_area, _x.left_beside.centerline.water_area, _x.left_beside.centerline.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.centerline.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v58 = val1.point
        _x = _v58
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.centerline.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.regulatory_elements.special_nodes = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v59 = val1.point
        _x = _v59
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.regulatory_elements.special_nodes.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.regulatory_elements.special_ways = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Way()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.task_area = str[start:end].decode('utf-8')
        else:
          val1.task_area = str[start:end]
        _x = val1
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.points = []
        for i in range(0, length):
          val2 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val2.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.type = str[start:end].decode('utf-8')
          else:
            val2.type = str[start:end]
          start = end
          end += 8
          (val2.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v60 = val2.point
          _x = _v60
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          val1.points.append(val2)
        self.left_beside.regulatory_elements.special_ways.append(val1)
      start = end
      end += 4
      (self.right_beside.id,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.right_beside.left_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.right_beside.left_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.right_beside.left_bound.is_forward, _x.right_beside.left_bound.open_concave_obs_det, _x.right_beside.left_bound.open_dynamic_obs_det, _x.right_beside.left_bound.open_foggy_det, _x.right_beside.left_bound.open_water_det, _x.right_beside.left_bound.foggy_area, _x.right_beside.left_bound.lawn_area, _x.right_beside.left_bound.water_area, _x.right_beside.left_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.left_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v61 = val1.point
        _x = _v61
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.left_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.right_beside.right_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.right_beside.right_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.right_beside.right_bound.is_forward, _x.right_beside.right_bound.open_concave_obs_det, _x.right_beside.right_bound.open_dynamic_obs_det, _x.right_beside.right_bound.open_foggy_det, _x.right_beside.right_bound.open_water_det, _x.right_beside.right_bound.foggy_area, _x.right_beside.right_bound.lawn_area, _x.right_beside.right_bound.water_area, _x.right_beside.right_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.right_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v62 = val1.point
        _x = _v62
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.right_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.right_beside.centerline.task_area = str[start:end].decode('utf-8')
      else:
        self.right_beside.centerline.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.right_beside.centerline.is_forward, _x.right_beside.centerline.open_concave_obs_det, _x.right_beside.centerline.open_dynamic_obs_det, _x.right_beside.centerline.open_foggy_det, _x.right_beside.centerline.open_water_det, _x.right_beside.centerline.foggy_area, _x.right_beside.centerline.lawn_area, _x.right_beside.centerline.water_area, _x.right_beside.centerline.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.centerline.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v63 = val1.point
        _x = _v63
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.centerline.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.regulatory_elements.special_nodes = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v64 = val1.point
        _x = _v64
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.regulatory_elements.special_nodes.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.regulatory_elements.special_ways = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Way()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.task_area = str[start:end].decode('utf-8')
        else:
          val1.task_area = str[start:end]
        _x = val1
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.points = []
        for i in range(0, length):
          val2 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val2.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.type = str[start:end].decode('utf-8')
          else:
            val2.type = str[start:end]
          start = end
          end += 8
          (val2.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v65 = val2.point
          _x = _v65
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          val1.points.append(val2)
        self.right_beside.regulatory_elements.special_ways.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.forward_following = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v66 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v66.task_area = str[start:end].decode('utf-8')
        else:
          _v66.task_area = str[start:end]
        _x = _v66
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v66.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v67 = val3.point
          _x = _v67
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v66.points.append(val3)
        _v68 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v68.task_area = str[start:end].decode('utf-8')
        else:
          _v68.task_area = str[start:end]
        _x = _v68
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v68.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v69 = val3.point
          _x = _v69
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v68.points.append(val3)
        _v70 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v70.task_area = str[start:end].decode('utf-8')
        else:
          _v70.task_area = str[start:end]
        _x = _v70
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v70.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v71 = val3.point
          _x = _v71
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v70.points.append(val3)
        _v72 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v72.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v73 = val3.point
          _x = _v73
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v72.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v72.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v74 = val4.point
            _x = _v74
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v72.special_ways.append(val3)
        self.forward_following.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.forward_right = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v75 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v75.task_area = str[start:end].decode('utf-8')
        else:
          _v75.task_area = str[start:end]
        _x = _v75
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v75.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v76 = val3.point
          _x = _v76
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v75.points.append(val3)
        _v77 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v77.task_area = str[start:end].decode('utf-8')
        else:
          _v77.task_area = str[start:end]
        _x = _v77
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v77.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v78 = val3.point
          _x = _v78
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v77.points.append(val3)
        _v79 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v79.task_area = str[start:end].decode('utf-8')
        else:
          _v79.task_area = str[start:end]
        _x = _v79
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v79.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v80 = val3.point
          _x = _v80
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v79.points.append(val3)
        _v81 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v81.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v82 = val3.point
          _x = _v82
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v81.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v81.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v83 = val4.point
            _x = _v83
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v81.special_ways.append(val3)
        self.forward_right.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.forward_left = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v84 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v84.task_area = str[start:end].decode('utf-8')
        else:
          _v84.task_area = str[start:end]
        _x = _v84
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v84.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v85 = val3.point
          _x = _v85
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v84.points.append(val3)
        _v86 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v86.task_area = str[start:end].decode('utf-8')
        else:
          _v86.task_area = str[start:end]
        _x = _v86
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v86.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v87 = val3.point
          _x = _v87
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v86.points.append(val3)
        _v88 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v88.task_area = str[start:end].decode('utf-8')
        else:
          _v88.task_area = str[start:end]
        _x = _v88
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v88.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v89 = val3.point
          _x = _v89
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v88.points.append(val3)
        _v90 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v90.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v91 = val3.point
          _x = _v91
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v90.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v90.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v92 = val4.point
            _x = _v92
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v90.special_ways.append(val3)
        self.forward_left.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.current_lane)
      buff.write(_struct_I.pack(length))
      for val1 in self.current_lane:
        buff.write(_get_struct_i().pack(val1.id))
        _v93 = val1.left_bound
        _x = _v93.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v93
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v93.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v93.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v94 = val3.point
          _x = _v94
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v95 = val1.right_bound
        _x = _v95.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v95
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v95.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v95.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v96 = val3.point
          _x = _v96
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v97 = val1.centerline
        _x = _v97.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v97
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v97.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v97.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v98 = val3.point
          _x = _v98
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v99 = val1.regulatory_elements
        length = len(_v99.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v99.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v100 = val3.point
          _x = _v100
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v99.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v99.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v101 = val4.point
            _x = _v101
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      buff.write(_get_struct_i().pack(self.left_beside.id))
      _x = self.left_beside.left_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.left_beside.left_bound.is_forward, _x.left_beside.left_bound.open_concave_obs_det, _x.left_beside.left_bound.open_dynamic_obs_det, _x.left_beside.left_bound.open_foggy_det, _x.left_beside.left_bound.open_water_det, _x.left_beside.left_bound.foggy_area, _x.left_beside.left_bound.lawn_area, _x.left_beside.left_bound.water_area, _x.left_beside.left_bound.vel_limit))
      length = len(self.left_beside.left_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.left_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v102 = val1.point
        _x = _v102
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.left_beside.right_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.left_beside.right_bound.is_forward, _x.left_beside.right_bound.open_concave_obs_det, _x.left_beside.right_bound.open_dynamic_obs_det, _x.left_beside.right_bound.open_foggy_det, _x.left_beside.right_bound.open_water_det, _x.left_beside.right_bound.foggy_area, _x.left_beside.right_bound.lawn_area, _x.left_beside.right_bound.water_area, _x.left_beside.right_bound.vel_limit))
      length = len(self.left_beside.right_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.right_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v103 = val1.point
        _x = _v103
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.left_beside.centerline.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.left_beside.centerline.is_forward, _x.left_beside.centerline.open_concave_obs_det, _x.left_beside.centerline.open_dynamic_obs_det, _x.left_beside.centerline.open_foggy_det, _x.left_beside.centerline.open_water_det, _x.left_beside.centerline.foggy_area, _x.left_beside.centerline.lawn_area, _x.left_beside.centerline.water_area, _x.left_beside.centerline.vel_limit))
      length = len(self.left_beside.centerline.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.centerline.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v104 = val1.point
        _x = _v104
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.left_beside.regulatory_elements.special_nodes)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.regulatory_elements.special_nodes:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v105 = val1.point
        _x = _v105
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.left_beside.regulatory_elements.special_ways)
      buff.write(_struct_I.pack(length))
      for val1 in self.left_beside.regulatory_elements.special_ways:
        _x = val1.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(val1.points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.points:
          buff.write(_get_struct_i().pack(val2.id))
          _x = val2.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val2.vlimit))
          _v106 = val2.point
          _x = _v106
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      buff.write(_get_struct_i().pack(self.right_beside.id))
      _x = self.right_beside.left_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.right_beside.left_bound.is_forward, _x.right_beside.left_bound.open_concave_obs_det, _x.right_beside.left_bound.open_dynamic_obs_det, _x.right_beside.left_bound.open_foggy_det, _x.right_beside.left_bound.open_water_det, _x.right_beside.left_bound.foggy_area, _x.right_beside.left_bound.lawn_area, _x.right_beside.left_bound.water_area, _x.right_beside.left_bound.vel_limit))
      length = len(self.right_beside.left_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.left_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v107 = val1.point
        _x = _v107
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.right_beside.right_bound.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.right_beside.right_bound.is_forward, _x.right_beside.right_bound.open_concave_obs_det, _x.right_beside.right_bound.open_dynamic_obs_det, _x.right_beside.right_bound.open_foggy_det, _x.right_beside.right_bound.open_water_det, _x.right_beside.right_bound.foggy_area, _x.right_beside.right_bound.lawn_area, _x.right_beside.right_bound.water_area, _x.right_beside.right_bound.vel_limit))
      length = len(self.right_beside.right_bound.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.right_bound.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v108 = val1.point
        _x = _v108
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      _x = self.right_beside.centerline.task_area
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8bd().pack(_x.right_beside.centerline.is_forward, _x.right_beside.centerline.open_concave_obs_det, _x.right_beside.centerline.open_dynamic_obs_det, _x.right_beside.centerline.open_foggy_det, _x.right_beside.centerline.open_water_det, _x.right_beside.centerline.foggy_area, _x.right_beside.centerline.lawn_area, _x.right_beside.centerline.water_area, _x.right_beside.centerline.vel_limit))
      length = len(self.right_beside.centerline.points)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.centerline.points:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v109 = val1.point
        _x = _v109
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.right_beside.regulatory_elements.special_nodes)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.regulatory_elements.special_nodes:
        buff.write(_get_struct_i().pack(val1.id))
        _x = val1.type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        buff.write(_get_struct_d().pack(val1.vlimit))
        _v110 = val1.point
        _x = _v110
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.right_beside.regulatory_elements.special_ways)
      buff.write(_struct_I.pack(length))
      for val1 in self.right_beside.regulatory_elements.special_ways:
        _x = val1.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(val1.points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.points:
          buff.write(_get_struct_i().pack(val2.id))
          _x = val2.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val2.vlimit))
          _v111 = val2.point
          _x = _v111
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.forward_following)
      buff.write(_struct_I.pack(length))
      for val1 in self.forward_following:
        buff.write(_get_struct_i().pack(val1.id))
        _v112 = val1.left_bound
        _x = _v112.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v112
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v112.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v112.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v113 = val3.point
          _x = _v113
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v114 = val1.right_bound
        _x = _v114.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v114
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v114.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v114.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v115 = val3.point
          _x = _v115
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v116 = val1.centerline
        _x = _v116.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v116
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v116.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v116.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v117 = val3.point
          _x = _v117
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v118 = val1.regulatory_elements
        length = len(_v118.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v118.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v119 = val3.point
          _x = _v119
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v118.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v118.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v120 = val4.point
            _x = _v120
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.forward_right)
      buff.write(_struct_I.pack(length))
      for val1 in self.forward_right:
        buff.write(_get_struct_i().pack(val1.id))
        _v121 = val1.left_bound
        _x = _v121.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v121
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v121.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v121.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v122 = val3.point
          _x = _v122
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v123 = val1.right_bound
        _x = _v123.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v123
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v123.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v123.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v124 = val3.point
          _x = _v124
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v125 = val1.centerline
        _x = _v125.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v125
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v125.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v125.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v126 = val3.point
          _x = _v126
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v127 = val1.regulatory_elements
        length = len(_v127.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v127.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v128 = val3.point
          _x = _v128
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v127.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v127.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v129 = val4.point
            _x = _v129
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.forward_left)
      buff.write(_struct_I.pack(length))
      for val1 in self.forward_left:
        buff.write(_get_struct_i().pack(val1.id))
        _v130 = val1.left_bound
        _x = _v130.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v130
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v130.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v130.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v131 = val3.point
          _x = _v131
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v132 = val1.right_bound
        _x = _v132.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v132
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v132.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v132.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v133 = val3.point
          _x = _v133
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v134 = val1.centerline
        _x = _v134.task_area
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v134
        buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
        length = len(_v134.points)
        buff.write(_struct_I.pack(length))
        for val3 in _v134.points:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v135 = val3.point
          _x = _v135
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v136 = val1.regulatory_elements
        length = len(_v136.special_nodes)
        buff.write(_struct_I.pack(length))
        for val3 in _v136.special_nodes:
          buff.write(_get_struct_i().pack(val3.id))
          _x = val3.type
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          buff.write(_get_struct_d().pack(val3.vlimit))
          _v137 = val3.point
          _x = _v137
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        length = len(_v136.special_ways)
        buff.write(_struct_I.pack(length))
        for val3 in _v136.special_ways:
          _x = val3.task_area
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
          _x = val3
          buff.write(_get_struct_8bd().pack(_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit))
          length = len(val3.points)
          buff.write(_struct_I.pack(length))
          for val4 in val3.points:
            buff.write(_get_struct_i().pack(val4.id))
            _x = val4.type
            length = len(_x)
            if python3 or type(_x) == unicode:
              _x = _x.encode('utf-8')
              length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            buff.write(_get_struct_d().pack(val4.vlimit))
            _v138 = val4.point
            _x = _v138
            buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.current_lane is None:
        self.current_lane = None
      if self.left_beside is None:
        self.left_beside = lanelet_map_msgs.msg.Lanelet()
      if self.right_beside is None:
        self.right_beside = lanelet_map_msgs.msg.Lanelet()
      if self.forward_following is None:
        self.forward_following = None
      if self.forward_right is None:
        self.forward_right = None
      if self.forward_left is None:
        self.forward_left = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.current_lane = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v139 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v139.task_area = str[start:end].decode('utf-8')
        else:
          _v139.task_area = str[start:end]
        _x = _v139
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v139.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v140 = val3.point
          _x = _v140
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v139.points.append(val3)
        _v141 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v141.task_area = str[start:end].decode('utf-8')
        else:
          _v141.task_area = str[start:end]
        _x = _v141
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v141.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v142 = val3.point
          _x = _v142
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v141.points.append(val3)
        _v143 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v143.task_area = str[start:end].decode('utf-8')
        else:
          _v143.task_area = str[start:end]
        _x = _v143
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v143.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v144 = val3.point
          _x = _v144
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v143.points.append(val3)
        _v145 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v145.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v146 = val3.point
          _x = _v146
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v145.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v145.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v147 = val4.point
            _x = _v147
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v145.special_ways.append(val3)
        self.current_lane.append(val1)
      start = end
      end += 4
      (self.left_beside.id,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.left_beside.left_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.left_beside.left_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.left_beside.left_bound.is_forward, _x.left_beside.left_bound.open_concave_obs_det, _x.left_beside.left_bound.open_dynamic_obs_det, _x.left_beside.left_bound.open_foggy_det, _x.left_beside.left_bound.open_water_det, _x.left_beside.left_bound.foggy_area, _x.left_beside.left_bound.lawn_area, _x.left_beside.left_bound.water_area, _x.left_beside.left_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.left_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v148 = val1.point
        _x = _v148
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.left_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.left_beside.right_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.left_beside.right_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.left_beside.right_bound.is_forward, _x.left_beside.right_bound.open_concave_obs_det, _x.left_beside.right_bound.open_dynamic_obs_det, _x.left_beside.right_bound.open_foggy_det, _x.left_beside.right_bound.open_water_det, _x.left_beside.right_bound.foggy_area, _x.left_beside.right_bound.lawn_area, _x.left_beside.right_bound.water_area, _x.left_beside.right_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.right_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v149 = val1.point
        _x = _v149
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.right_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.left_beside.centerline.task_area = str[start:end].decode('utf-8')
      else:
        self.left_beside.centerline.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.left_beside.centerline.is_forward, _x.left_beside.centerline.open_concave_obs_det, _x.left_beside.centerline.open_dynamic_obs_det, _x.left_beside.centerline.open_foggy_det, _x.left_beside.centerline.open_water_det, _x.left_beside.centerline.foggy_area, _x.left_beside.centerline.lawn_area, _x.left_beside.centerline.water_area, _x.left_beside.centerline.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.centerline.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v150 = val1.point
        _x = _v150
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.centerline.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.regulatory_elements.special_nodes = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v151 = val1.point
        _x = _v151
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.left_beside.regulatory_elements.special_nodes.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.left_beside.regulatory_elements.special_ways = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Way()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.task_area = str[start:end].decode('utf-8')
        else:
          val1.task_area = str[start:end]
        _x = val1
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.points = []
        for i in range(0, length):
          val2 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val2.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.type = str[start:end].decode('utf-8')
          else:
            val2.type = str[start:end]
          start = end
          end += 8
          (val2.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v152 = val2.point
          _x = _v152
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          val1.points.append(val2)
        self.left_beside.regulatory_elements.special_ways.append(val1)
      start = end
      end += 4
      (self.right_beside.id,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.right_beside.left_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.right_beside.left_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.right_beside.left_bound.is_forward, _x.right_beside.left_bound.open_concave_obs_det, _x.right_beside.left_bound.open_dynamic_obs_det, _x.right_beside.left_bound.open_foggy_det, _x.right_beside.left_bound.open_water_det, _x.right_beside.left_bound.foggy_area, _x.right_beside.left_bound.lawn_area, _x.right_beside.left_bound.water_area, _x.right_beside.left_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.left_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v153 = val1.point
        _x = _v153
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.left_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.right_beside.right_bound.task_area = str[start:end].decode('utf-8')
      else:
        self.right_beside.right_bound.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.right_beside.right_bound.is_forward, _x.right_beside.right_bound.open_concave_obs_det, _x.right_beside.right_bound.open_dynamic_obs_det, _x.right_beside.right_bound.open_foggy_det, _x.right_beside.right_bound.open_water_det, _x.right_beside.right_bound.foggy_area, _x.right_beside.right_bound.lawn_area, _x.right_beside.right_bound.water_area, _x.right_beside.right_bound.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.right_bound.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v154 = val1.point
        _x = _v154
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.right_bound.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.right_beside.centerline.task_area = str[start:end].decode('utf-8')
      else:
        self.right_beside.centerline.task_area = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.right_beside.centerline.is_forward, _x.right_beside.centerline.open_concave_obs_det, _x.right_beside.centerline.open_dynamic_obs_det, _x.right_beside.centerline.open_foggy_det, _x.right_beside.centerline.open_water_det, _x.right_beside.centerline.foggy_area, _x.right_beside.centerline.lawn_area, _x.right_beside.centerline.water_area, _x.right_beside.centerline.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.centerline.points = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v155 = val1.point
        _x = _v155
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.centerline.points.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.regulatory_elements.special_nodes = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Node()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.type = str[start:end].decode('utf-8')
        else:
          val1.type = str[start:end]
        start = end
        end += 8
        (val1.vlimit,) = _get_struct_d().unpack(str[start:end])
        _v156 = val1.point
        _x = _v156
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.right_beside.regulatory_elements.special_nodes.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.right_beside.regulatory_elements.special_ways = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Way()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.task_area = str[start:end].decode('utf-8')
        else:
          val1.task_area = str[start:end]
        _x = val1
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.points = []
        for i in range(0, length):
          val2 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val2.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.type = str[start:end].decode('utf-8')
          else:
            val2.type = str[start:end]
          start = end
          end += 8
          (val2.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v157 = val2.point
          _x = _v157
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          val1.points.append(val2)
        self.right_beside.regulatory_elements.special_ways.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.forward_following = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v158 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v158.task_area = str[start:end].decode('utf-8')
        else:
          _v158.task_area = str[start:end]
        _x = _v158
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v158.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v159 = val3.point
          _x = _v159
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v158.points.append(val3)
        _v160 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v160.task_area = str[start:end].decode('utf-8')
        else:
          _v160.task_area = str[start:end]
        _x = _v160
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v160.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v161 = val3.point
          _x = _v161
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v160.points.append(val3)
        _v162 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v162.task_area = str[start:end].decode('utf-8')
        else:
          _v162.task_area = str[start:end]
        _x = _v162
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v162.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v163 = val3.point
          _x = _v163
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v162.points.append(val3)
        _v164 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v164.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v165 = val3.point
          _x = _v165
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v164.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v164.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v166 = val4.point
            _x = _v166
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v164.special_ways.append(val3)
        self.forward_following.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.forward_right = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v167 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v167.task_area = str[start:end].decode('utf-8')
        else:
          _v167.task_area = str[start:end]
        _x = _v167
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v167.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v168 = val3.point
          _x = _v168
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v167.points.append(val3)
        _v169 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v169.task_area = str[start:end].decode('utf-8')
        else:
          _v169.task_area = str[start:end]
        _x = _v169
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v169.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v170 = val3.point
          _x = _v170
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v169.points.append(val3)
        _v171 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v171.task_area = str[start:end].decode('utf-8')
        else:
          _v171.task_area = str[start:end]
        _x = _v171
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v171.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v172 = val3.point
          _x = _v172
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v171.points.append(val3)
        _v173 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v173.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v174 = val3.point
          _x = _v174
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v173.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v173.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v175 = val4.point
            _x = _v175
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v173.special_ways.append(val3)
        self.forward_right.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.forward_left = []
      for i in range(0, length):
        val1 = lanelet_map_msgs.msg.Lanelet()
        start = end
        end += 4
        (val1.id,) = _get_struct_i().unpack(str[start:end])
        _v176 = val1.left_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v176.task_area = str[start:end].decode('utf-8')
        else:
          _v176.task_area = str[start:end]
        _x = _v176
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v176.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v177 = val3.point
          _x = _v177
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v176.points.append(val3)
        _v178 = val1.right_bound
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v178.task_area = str[start:end].decode('utf-8')
        else:
          _v178.task_area = str[start:end]
        _x = _v178
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v178.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v179 = val3.point
          _x = _v179
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v178.points.append(val3)
        _v180 = val1.centerline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v180.task_area = str[start:end].decode('utf-8')
        else:
          _v180.task_area = str[start:end]
        _x = _v180
        start = end
        end += 16
        (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v180.points = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v181 = val3.point
          _x = _v181
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v180.points.append(val3)
        _v182 = val1.regulatory_elements
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v182.special_nodes = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Node()
          start = end
          end += 4
          (val3.id,) = _get_struct_i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.type = str[start:end].decode('utf-8')
          else:
            val3.type = str[start:end]
          start = end
          end += 8
          (val3.vlimit,) = _get_struct_d().unpack(str[start:end])
          _v183 = val3.point
          _x = _v183
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          _v182.special_nodes.append(val3)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v182.special_ways = []
        for i in range(0, length):
          val3 = lanelet_map_msgs.msg.Way()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val3.task_area = str[start:end].decode('utf-8')
          else:
            val3.task_area = str[start:end]
          _x = val3
          start = end
          end += 16
          (_x.is_forward, _x.open_concave_obs_det, _x.open_dynamic_obs_det, _x.open_foggy_det, _x.open_water_det, _x.foggy_area, _x.lawn_area, _x.water_area, _x.vel_limit,) = _get_struct_8bd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val3.points = []
          for i in range(0, length):
            val4 = lanelet_map_msgs.msg.Node()
            start = end
            end += 4
            (val4.id,) = _get_struct_i().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val4.type = str[start:end].decode('utf-8')
            else:
              val4.type = str[start:end]
            start = end
            end += 8
            (val4.vlimit,) = _get_struct_d().unpack(str[start:end])
            _v184 = val4.point
            _x = _v184
            start = end
            end += 24
            (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
            val3.points.append(val4)
          _v182.special_ways.append(val3)
        self.forward_left.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
_struct_8bd = None
def _get_struct_8bd():
    global _struct_8bd
    if _struct_8bd is None:
        _struct_8bd = struct.Struct("<8bd")
    return _struct_8bd
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
